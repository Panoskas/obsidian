Clients and servers are stubbed so that remote procedure call would seem like local procedure calls, but over a network boundary. Instead of accessing remote services by sending and receiving messages, a client invokes services by making a local procedure call. The local procedure hides the details of the network communication.

The machine making the procedure call is termed as the ‘client’ and the machine executing the called procedure is called the ‘server’. For every procedure being called, there should be a code which suggests the machine that has to be contacted for the procedure. Such kind of code is called a ‘Stub’.

gRPC by Google and Square represents an incremental step in the progress of scaling RPC for cloud solutions. gRPC can use protocol buffer for data serialization. This makes payloads faster, smaller and simpler. Just like REST, gRPC can be used cross-language which means, that if you have written a web service in Golang, a Java written application can still use that web service, which makes gRPC web services very scalable.

gRPC runs on top of TCP, which means it outsources the problems of connection management and reliably transmitting the request and reply messages of arbitrary size. Second, gRPC actually runs on top of a secured version of TCP called Transport Layer Security (TLS) means it outsources responsibility for securing the communication channel, gRPC actually runs on top of HTTP/2 (which is itself layered on top of TCP and TLS), meaning gRPC outsources yet two other problems: (1) efficiently encoding/compressing binary data into a message, (2) multiplexing multiple remote procedures calls onto a single TCP connection. It makes use of binary data rather than just text which makes the communication more compact and more efficient.

It is also type-safe. This basically means that you can’t give an apple when e a banana is expected. When the server expects an integer, gRPC won’t allow you to send a string because these are two different types.

Workflow with gRPC is quite simple, first, you need to define .proto file defining services, requests and response formats, and then you copy this file to all projects which will communicate with each other. The only thing you need to do is to convert your domain objects to the generated classes. Protocol buffer is used to define endpoints schemas. Protocol Buffers or protobufs, are a way of defining and serializing structured data into an efficient binary format, also developed by Google. Protocol buffers were one of the main reasons we chose gRPC as the two work very well together. We previously had many issues related to versioning that we wanted to fix. Microservices mean we have to roll changes and updates constantly and so we need interfaces that can adapt and stay forward and backwards compatible, and protobufs are very good for this. Since they are in a binary format, they are also small payloads that are quick to send over the wire.